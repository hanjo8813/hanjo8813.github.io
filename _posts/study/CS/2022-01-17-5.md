---
title:  "[운영체제] 가상 메모리"
date: 2022-01-17
categories:
  - CS

# 고정값
classes: wide
toc: false
toc_sticky: false
---

가상 메모리에 대해 알아보자

## 가상 메모리란?

### 정의

- 프로세스가 실행될 때 코드 전체를 메모리에 로드하지만, 코드의 일부에서만 대부분의 시간을 사용함
    - 특정 순간에는 항상 작은 양의 주소공간을 사용
    - 코드 용량이 메모리 용량보다 큰 프로그램은 실행시킬 수 없음
- **물리적 메모리 용량의 한계를 극복하기 위한 기술**

### 역할

- 프로세스 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 둔다.
    - 프로세스 전체가 물리적 메모리에 존재하는 것처럼 수행된다
- 메모리에 작은 양의 주소 공간만 있으면 프로세스를 수행할 수 있게 되고, 더 많은 프로세스를 동시 실행 가능

### 용어 정리

- disk swap 영역 == 가상메모리 / 페이지
- 물리메모리 == 메인메모리 / 프레임

<br>

## 페이징 기법

- 프로세스를 **고정 분할** 기법을 사용하여 일정 크기의 페이지로 잘라 메모리에 적재하는 방식

<img width="700" alt="image" src="https://user-images.githubusercontent.com/71180414/149677880-7583f98f-88bc-486e-aeaa-f014183e9c12.png"/>


- 가상 메모리와 물리 메모리 영역의 주소 공간을 동일한 크기로 나눈다
    - 가상 메모리 블록 -> **페이지**
    - 물리 메모리 블록 -> **프레임**

### 프로세스 테이블

- 페이지와 프레임은 **프로세스 페이지 테이블**을 사용하여 매핑한다
- 각 프로세스는 자신만의 페이지 테이블을 가진다.

<img width="364" alt="image" src="https://user-images.githubusercontent.com/71180414/149678243-84ff2f10-74a6-4169-b1ff-1598a5e41042.png"/>

- 페이지 테이블은 배열이라고 생각하면 된다
    - 인덱스가 페이지 번호이고 배열의 값이 프레임 번호
- 하지만 페이지 테이블의 용량이 커서 성능문제가 발생하므로 캐시(TLB)를 사용한다

<br>

## 세그먼테이션 기법

<img width="700" alt="image" src="https://user-images.githubusercontent.com/71180414/149679442-6fb45e66-002d-4d72-9b59-23be57410452.png"/>

- 프로세스를 **가변 분할** 기법을 사용하여 가변 영역인 세그먼트로 잘라 메모리에 적재하는 방식
- **세그먼트 테이블**을 사용한다
    - index : 세그먼트 번호
    - base : 시작 주소
    - limit : 세그먼트 크기
- 데이터 공유에 유리하다
    - ex) 코드, 데이터, 스택영역을 나눌 때 각 영역에 알맞게 나누기 때문에 영역끼리 섞이지 않음

<br>

## 페이징 vs 세그먼테이션

||페이징|세그먼테이션|
|---|---|---|
|분할방식|고정분할|가변분할|
|외부단편화|X|O|
|내부단편화|O|X|

<br>

## 요구 페이징

- 초기에는 필요한 페이지만을 메인메모리에 적재하고, 프로세스 실행중에 실제로 필요한 페이지를 적재하는 기법
    - 이를 Lazy swapper라 함.
    - 가상메모리를 페이지로 나눈 뒤 메인메모리 프레임에 적재
- **장점** : 메모리 절약, 프로세스 응답 속도 향상
- **단점** : page fault 발생

### 원리

<img width="310" alt="image" src="https://user-images.githubusercontent.com/71180414/149810180-8cdc27a7-3986-4ee5-95cc-65c96c91b7db.png"/>

- 페이지가 실제로 물리메모리에 적재되었는지의 여부는 페이지 테이블을 통해 판단한다.
- Valid-Invalid Bit를 활용
    - `v` : 물리메모리에 적재되어 있음
    - `i` : 적재되어 있지 않음

<br>

## Page Fault

1. 프로세스가 특정 페이지를 요청 -> 메인메모리에 페이지 존재 X
2. 제어권이 운영체제로 넘어가고 페이지를 가져올 프레임 공간을 찾음(free frame)
    - 공간이 없다면 페이지 교체 발생
3. 페이지 테이블에서 가상메모리(디스크) 주소를 확인 -> 메인메모리에 페이지 저장 (disk I/O이므로 상태가 blocked로 변경)
4. 페이지 테이블 업데이트 후 ready 상태로 변경

<br>

## 페이지 교체 알고리즘

- page fault가 발생하여 페이지를 가져올 메인메모리의 프레임 공간이 부족할 경우 특정 프레임을 교체해야하는데, 가장 적절한 프레임을 선택하는 알고리즘이다.

### FIFO (First In First Out)

- **가장 먼저 들어온 페이지를 교체 (선입선출)**
- 큐로 구현

### OPT (Optimal)

- **앞으로 가장 오랫동안 사용되지 않을 페이지를 교체**
- 가장 이상적인 방법이지만 적절한 페이지를 예측하는것이 불가능함.

### LRU (Least Recently Used)

- **가장 오랫동안 사용되지 않은 페이지를 교체** 
- 큐로 구현
- 참조된 페이지 시간을 기록해야하므로 오버헤드가 발생

### NRU (Not Recently Used)

- **최근에 사용하지 않은 페이지 교체**
- LRU와 근사한 알고리즘
- 적은 오버헤드로 적절한 성능
- 두 개의 비트를 사용
    - `참조 비트 r` : 페이지가 참조되지 않았으면 0, 호출되었으면 1 (참조비트는 주기적으로 0으로 변경)
    - `변형 비트 m` : 페이지 내용이 변경되지 않으면 0, 변경되었으면 1
    - 교체 우선순위 예시
        1. r = 0 / m = 0
        2. r = 0 / m = 1
        3. r = 1 / m = 0
        4. r = 1 / m = 1

### LFU (Least Frequently Used)

- **참조 횟수가 가장 적은 페이지를 교체**
- 가장 최근에 불러운 페이지가 교체될 수 있고, 구현이 복잡함

### MFU (Most Frequently Used)

- **참조 횟수가 가장 많은 페이지를 교체**
- 가장 많이 사용된 페이지는 앞으로 사용되지 않을것이라는 가정

<br>