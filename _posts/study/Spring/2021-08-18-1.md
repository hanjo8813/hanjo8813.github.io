---
title:  "Spring 용어정리"
date: 2021-08-18
categories: 
  - Spring

# 고정값
classes: wide
toc: false
toc_sticky: false
---

일단 기본 용어부터 대충 정리해놓기


## 스프링 계층구조 

![image](https://user-images.githubusercontent.com/71180414/129831418-dd2bab43-4319-48f7-82b3-2d185f869de0.png){:width='700'}

- 도메인 : 비즈니스 그 자체를 뜻함
    - `Entity` : 각 엔티티는 유일하기에 구분할 수 있는 식별자를 가지고 있다. 시간에 따라 상태가 변경됨
    - `VO` : 고유 불변한 객체이다.
    - `DTO` : 각 계층간 데이터 **교환**을 위한 객체 (데이터 바인딩용)
    - `DAO` : DB를 사용해 데이터 조회, **조작**하는 객체
- `Presentation`(Web) : 사용자와 상호작용. 여기서 View, Controller가 동작한다
- `Service`(Business) : 비즈니스 로직을 담당하는 계층
- `Repository`(Data Access) : DAO의 구현부분

<br>

## DI (Dependency Injection)

<br>


## IoC (Inversion of Control)

- 제어의 역전을 뜻한다
- 객체 생성 및 관리를 `IoC 컨테이너`라고 불리는 클래스에서 모두 수행하게 된다.
- 팩토리 메소드 패턴과 매우 유사한 것 같다

### Spring에서의 IoC

- `BeanFactory` : Spring에서 지원하며, IoC 컨테이너의 기능을 정의하는 인터페이스이다.
- `Bean` : IoC 컨테이너에 의해 생성되고 관리되는 객체이다
- `ApplicationContext` : BeanFactory가 제공하는 기능 + AOP, 메시지 처리, 이벤트 처리 등의 기능을 제공한다.
- `Configuration MetaData` : Bean 객체 생성시 메타데이터를 ApplicationContext로부터 받아오는 것
    - `GenericXmlApplicationContext` : xml 기반 구현체 생성
    - `AnnotationConfigApplicattionContext` : 어노테이션 기반 구현체 생성

### Circular Dependency

- IoC 컨테이너 내의 Bean들은 서로 참조가 가능하다.
- 하지만 순차적으로 참조하는 것이 아닌 순환하여 참조하게 된다면 오류가 발생한다

<br>


## Streotype Annotation

- `@Configuration` : App Context(IoC 컨테이너)로 등록하기
- `@Bean` : 

### Component

- 컴포넌트 어노테이션엔 다양한 종류가 존재한다.
- 어노테이션을 달아놓은 파일을 컴포넌트라고 칭한다
- `@ComponentScan` : 컴포넌트들을 모두 스캔하여 Bean으로 등록한다. 스캔 범위 지정이 가능
    - `@ComponentScan(basePackages = {"패키지명", ...}`
    - `@ComponentScan(basePackageClasses = {클래스, ...})`
- `@Service` : 
- `@Repository` : 

<br>

## Auto Wired

- 스프링의 ComponentScan 사용시 Bean을 직접 지정하지 않는다.
- 따라서 @Bean으로 직접 의존관계 주입해주던 방식을 자동화해주는 Auto Wired 기능이 등장.
- 컴포넌트로 등록된 파일 내에서 생성자에 `@Autowired` 어노테이션을 붙여준다.
    - 초기화시 필요한 모든 의존관계가 형성됨
    - 잘못된 패턴을 찾을 수 있도록 도와줌
    - 테스트를 쉽게 해줌
    - 불변성을 확보
- 만약 생성자와 관련된 Bean이 두개 이상이라면? => 해당 Bean에 어노테이션을 달아줘야함.
    - `@Primary` : 가장 우선이 되는 Bean을 뜻함
    - `@Qualifier("별명")` : Bean 파일에서 별명 설정 후, 생성자에서 명시해줘야함

<br>


## Bean Scope

- 총 6개의 Bean Scope가 존재함
    - `singleton`, `prototype`, `request`, `session`, `application`, `websocket`
- 기본적으로 싱글톤 스코프를 가진다.
- 싱글톤으로 생성된 Bean을 객체로 가져오면 모두 같은 주소를 가진다
- 다른 주소를 가지게하려면 prototype 스코프로 변경해야함

### Scope 변경하기

- 컴포넌트 파일 정의시 어노테이션을 통해 스코프를 정의할 수 있다
- `@Scope(value = ConfigurableBeanFactory.스코프문자열)`

```java
@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
```

<br>

## Bean Life Cycle

- AppContext(IoC 컨테이너) 등록시 연관된 Bean들이 생성된다.
- AppContext는 `.close()` 메소드로 종료할 수 있으며, 종료시 내부의 모든 Bean들이 소멸된다.
- Bean의 생성과 소멸시에 콜백함수를 설정할 수 있다.


### Bean 생성 콜백

1. @PostConstruct 어노테이션이 적용된 메소드 호출
2. Bean이 InitializingBean 인터페이스 구현시 afterPropertiesSet 호출
3. @Bean 어노테이션의 initMethod에 설정한 메소드 호출

### Bean 소멸 콜백

1. @PreDestroy 어노테이션이 적용된 메소드 호출
2. Bean이 DisposableBean 인터페이스 구현시 destroy 호출
3. @Bean 어노테이션의 destroyMethod에 설정한 메소드 호출

<br>

## Properties

- Spring 생성시 자동생성되며, resources 폴더 하위에 있음
- DB 접속정보나 포트정보 등등을 정의하는 것
- 보통 환경변수로 지정하고 싶은 것을 써놓는 듯?

### 사용법

- `application.properties`파일에 `변수명=값` 형태로 저장한다.
- 변수 사용시 AppContext에 `@PropertySource("application.properties")` 어노테이션을 달아준 후 컨테이너 생성하면됨.
- 컴포넌트 내에서 `@Value()` 어노테이션을 사용해 프로퍼티(환경변수) 값을 가져올 수 있다.
    - 시스템 환경변수도 가져올 수 있다.
    - 만약 프로퍼티 등록 키값과 시스템 키값이 동일하다면, 시스템이 우선순위가 더 높음.
- 생성자에도 `@Value()` 어노테이션을 지정할 수 있어서 프로퍼티를 받아주는 클래스를 따로 만들기도 함

<br>

## YAML

- 어디선가 많이 본 녀석이다.
- Spring의 기본 프로퍼티 확장자는 `.properties`이고 다른 확장자는 지원 X (Boot에서는 지원함)
- 따라서 `.yaml`으로 작성된 파일을 프로퍼티로 읽어오기 위해선 PropertySource Factory를 구현해야한다

### @ConfigurationProperties

- 리스트 바인딩을 위해선 스프링'부트'에서 제공하는 `@ConfigurationProperties`를 사용해야함
- 바인딩용 클래스에 해당 어노테이션을 달고 Prefix를 지정하여 해당 프리픽스 하위 데이터를 바인딩함.
- 해당 클래스에는 Getter와 Setter가 필수적으로 존재해야함.
- 프로퍼티가 적을땐 `@Value`로 바인딩해도 되지만, 많아지면 일일히 하기 힘드니까 이런 방법을 씀!!